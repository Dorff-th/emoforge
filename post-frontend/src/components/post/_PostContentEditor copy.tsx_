import { forwardRef, useCallback, useEffect, useMemo, useRef } from "react";
import { Editor } from "@toast-ui/react-editor";
import "@toast-ui/editor/dist/toastui-editor.css";
import axiosAttach from "@/api/axiosAttach";
import { useAppDispatch, useAppSelector } from "@/store/hooks";
import { addToast as showToast } from "@/store/slices/toastSlice";
import { fixContentForEditor } from "@/utils/contentUrlHelper";
import { backendBaseUrl } from "@/config/config";
import { v4 as uuidv4 } from "uuid";

interface Props {
  initialValue?: string;
  onChange: (val: string) => void;
  groupTempKey?: string;
}

interface AttachUploadResponseDto {
  id: number;
  fileName: string;
  originFileName: string;
  fileType: string;
  fileUrl?: string;
  publicUrl?: string;
  url?: string;
  createdAt: string;
}

const PostContentEditor = forwardRef<Editor, Props>(
  ({ initialValue, onChange, groupTempKey }, ref) => {
    const dispatch = useAppDispatch();
    const memberUuid = useAppSelector((state) => state.auth.user?.uuid);

    const tempKeyRef = useRef<string>(groupTempKey ?? uuidv4());

    const editorInitialValue = useMemo(() => {
      if (!initialValue) {
        return "";
      }

      // Use initialValue only on mount so the editor keeps its internal state afterward.
      return fixContentForEditor(initialValue);
    }, [initialValue]);

    const handleImageUpload = useCallback(
      async (blob: Blob, callback: (url: string, altText: string) => void) => {
        if (!memberUuid) {
          dispatch(
            showToast({
              type: "error",
              text: "Sign in to upload images.",
            }),
          );
          return false;
        }

        const formData = new FormData();

        formData.append("file", blob);
        formData.append("uploadType", "EDITOR_IMAGE");
        formData.append("memberUuid", memberUuid);
        formData.append("attachmentStatus", "TEMP");
        formData.append("tempKey", tempKeyRef.current);
        formData.append("groupTempKey", tempKeyRef.current);

        try {
          const { data } = await axiosAttach.post<AttachUploadResponseDto>(
            "/attach",
            formData,
            {
              headers: { "Content-Type": "multipart/form-data" },
            },
          );

          const imageUrl = data.publicUrl ?? data.fileUrl ?? data.url;

          if (!imageUrl) {
            throw new Error("Attachment service did not return an accessible URL.");
          }

          const resolvedUrl = imageUrl.startsWith("http") ? imageUrl : `${backendBaseUrl}${imageUrl}`;
          const altText = (blob as File).name ?? "editor image";
          // Ensure preview uses a reachable URL even when API responds with a relative path.
          callback(resolvedUrl, altText);
        } catch (error) {
          console.error("Image upload failed:", error);
          dispatch(
            showToast({
              type: "error",
              text: "Image upload failed.",
            }),
          );
        }

        return false;
      },
      [dispatch, memberUuid],
    );

    useEffect(() => {
      if (!ref || typeof ref === "function") return;
      const editorInstance = ref.current?.getInstance();
      if (!editorInstance) return;

      if (typeof editorInstance.removeHook === "function") {
        editorInstance.removeHook("addImageBlobHook");
      }

      editorInstance.addHook("addImageBlobHook", handleImageUpload);

      return () => {
        if (typeof editorInstance.removeHook === "function") {
          editorInstance.removeHook("addImageBlobHook");
        }
      };
    }, [handleImageUpload, ref]);

    const handleEditorChange = useCallback(() => {
      if (!ref || typeof ref === "function") return;
      const editorInstance = ref.current?.getInstance();
      if (!editorInstance) return;

      onChange(editorInstance.getMarkdown());
    }, [onChange, ref]);

    return (
      <div className="border rounded-lg overflow-hidden">
        <Editor
          ref={ref}
          height="400px"
          initialEditType="markdown"
          previewStyle="vertical"
          placeholder="Write your content..."
          useCommandShortcut={true}
          initialValue={editorInitialValue}
          onChange={handleEditorChange}
        />
      </div>
    );
  },
);

PostContentEditor.displayName = "PostContentEditor";

export default PostContentEditor;



